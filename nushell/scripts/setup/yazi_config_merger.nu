#!/usr/bin/env nu
# Simple Yazi Configuration Merger
# Merges two layers: Yazelix defaults + User overrides

use ../utils/constants.nu [YAZELIX_STATE_DIR]

# Get modification time of a file, or 0 if file doesn't exist
def get_mtime [path: string] {
    if ($path | path exists) {
        let expanded_path = ($path | path expand)
        let file_info = (ls $expanded_path | get 0)
        ($file_info.modified | into int)
    } else {
        0
    }
}

# Check if merged configs are up-to-date
def is_yazi_config_current [
    merged_dir: string,
    yazelix_dir: string
] {
    let config_files = ["yazi.toml", "keymap.toml", "theme.toml", "init.lua", "package.toml"]
    
    for file in $config_files {
        let merged_path = $"($merged_dir)/($file)"
        let yazelix_path = $"($yazelix_dir)/yazelix_($file)"
        let user_path = $"($yazelix_dir)/personal/($file)"
        
        let merged_mtime = get_mtime $merged_path
        let yazelix_mtime = get_mtime $yazelix_path
        let user_mtime = get_mtime $user_path
        
        # If any source is newer than merged, need to regenerate
        if ($yazelix_mtime > $merged_mtime) or ($user_mtime > $merged_mtime) {
            return false
        }
    }
    
    true
}

# Read a config file as raw text with error handling
def read_config_file [path: string, name: string] {
    if ($path | path exists) {
        try {
            open $path --raw
        } catch {|err|
            print $"‚ö†Ô∏è  Could not read ($name): ($err.msg)"
            ""
        }
    } else {
        ""
    }
}

# Merge TOML files (intelligent merging)
def merge_toml_files [yazelix_content: string, user_content: string, file_name: string] {
    # Parse both TOML contents if they exist and are valid
    let yazelix_toml = if ($yazelix_content | str trim | is-empty) {
        {}
    } else {
        try {
            $yazelix_content | from toml
        } catch {
            print $"‚ö†Ô∏è  Warning: Could not parse Yazelix TOML for ($file_name), using as raw text"
            {}
        }
    }
    
    let user_toml = if ($user_content | str trim | is-empty) {
        {}
    } else {
        try {
            # Remove comment lines before parsing to avoid TOML parsing issues
            let clean_user_content = ($user_content | lines | where not ($it | str starts-with "#") | str join "\n")
            if ($clean_user_content | str trim | is-empty) {
                {}
            } else {
                $clean_user_content | from toml
            }
        } catch {
            print $"‚ö†Ô∏è  Warning: Could not parse user TOML for ($file_name), using as raw text"
            {}
        }
    }
    
    # Merge the TOML structures (user settings override Yazelix defaults)
    let merged_toml = ($yazelix_toml | merge $user_toml)
    
    # Convert back to TOML with header
    let header = [
        $"# ========================================",
        $"# MERGED YAZI CONFIG: ($file_name)",
        $"# ========================================",
        $"# This file is automatically generated by Yazelix.",
        $"# Do not edit directly - changes will be lost!",
        $"#",
        $"# To customize Yazi, edit:",
        $"#   - configs/yazi/personal/($file_name) - your personal settings",
        $"#",
        $"# Generated: (date now | format date '%Y-%m-%d %H:%M:%S')",
        $"# ========================================",
        ""
    ] | str join "\n"
    
    let toml_content = if ($merged_toml | is-empty) {
        "# No configuration settings found"
    } else {
        try {
            $merged_toml | to toml
        } catch {
            # Fallback to concatenation if TOML generation fails
            print $"‚ö†Ô∏è  Warning: Could not generate TOML for ($file_name), falling back to concatenation"
            [
                $"# === YAZELIX DEFAULTS ===",
                $yazelix_content,
                "",
                $"# === USER OVERRIDES ===", 
                $user_content
            ] | str join "\n"
        }
    }
    
    $header + $toml_content
}

# Merge Lua files (simple concatenation)
def merge_lua_files [yazelix_content: string, user_content: string, file_name: string] {
    let merged = [
        $"-- ========================================",
        $"-- MERGED YAZI CONFIG: ($file_name)",
        $"-- ========================================",
        $"-- This file is automatically generated by Yazelix.",
        $"-- Do not edit directly - changes will be lost!",
        $"--",
        $"-- To customize Yazi, edit:",
        $"--   - configs/yazi/personal/($file_name) - your personal settings",
        $"--",
        $"-- Generated: (date now | format date '%Y-%m-%d %H:%M:%S')",
        $"-- ========================================",
        "",
        $"-- === YAZELIX DEFAULTS ===",
        $yazelix_content,
        "",
        $"-- === USER OVERRIDES ===",
        $user_content,
        ""
    ] | str join "\n"
    
    $merged
}

# Merge individual config file
def merge_config_file [
    yazelix_dir: string,
    merged_dir: string,
    file_name: string
] {
    let yazelix_path = $"($yazelix_dir)/yazelix_($file_name)"
    let user_path = $"($yazelix_dir)/personal/($file_name)"
    let merged_path = $"($merged_dir)/($file_name)"
    
    print $"   üìÑ Merging ($file_name)..."
    
    # Read source files
    let yazelix_content = read_config_file $yazelix_path "Yazelix defaults"
    let user_content = read_config_file $user_path "personal overrides"
    
    # Merge based on file type
    let merged_content = if ($file_name | str ends-with ".lua") {
        merge_lua_files $yazelix_content $user_content $file_name
    } else {
        merge_toml_files $yazelix_content $user_content $file_name
    }
    
    # Write merged file (overwrite if exists)
    try {
        $merged_content | save --force $merged_path
        print $"     ‚úÖ ($file_name) merged successfully"
    } catch {|err|
        print $"     ‚ùå Failed to merge ($file_name): ($err.msg)"
    }
}

# Copy plugins directory
def copy_plugins_directory [yazelix_dir: string, merged_dir: string] {
    let source_plugins_dir = $"($yazelix_dir)/plugins"
    let user_plugins_dir = $"($yazelix_dir)/personal/plugins"
    let target_plugins_dir = $"($merged_dir)/plugins"
    
    print "   üìÅ Copying plugins directory..."
    
    # Remove existing plugins dir if it exists
    if ($target_plugins_dir | path exists) {
        rm -rf $target_plugins_dir
    }
    
    # Copy Yazelix plugins first
    if ($source_plugins_dir | path exists) {
        try {
            cp -r $source_plugins_dir $target_plugins_dir
            print $"     ‚úÖ Yazelix plugins copied"
        } catch {|err|
            print $"     ‚ùå Failed to copy Yazelix plugins: ($err.msg)"
        }
    }
    
    # Copy user plugins (overriding Yazelix plugins with same name)
    if ($user_plugins_dir | path exists) {
        try {
            let user_plugin_dirs = (ls $user_plugins_dir | where type == dir | get name)
            for plugin_dir in $user_plugin_dirs {
                let plugin_name = ($plugin_dir | path basename)
                let target_plugin_dir = $"($target_plugins_dir)/($plugin_name)"
                
                # Remove existing plugin if it exists
                if ($target_plugin_dir | path exists) {
                    rm -rf $target_plugin_dir
                }
                
                cp -r $plugin_dir $target_plugin_dir
            }
            print $"     ‚úÖ Personal plugins copied (overriding Yazelix plugins)"
        } catch {|err|
            print $"     ‚ùå Failed to copy personal plugins: ($err.msg)"
        }
    }
}

# Ensure directory exists
def ensure_dir [path: string] {
    let dir = ($path | path dirname)
    if not ($dir | path exists) {
        mkdir $dir
    }
}

# Main function: Generate merged Yazi configuration
export def generate_merged_yazi_config [yazelix_dir: string] {
    # Define paths
    let state_dir = ($YAZELIX_STATE_DIR | path expand)
    let merged_config_dir = $"($state_dir)/configs/yazi"
    let source_config_dir = $"($yazelix_dir)/configs/yazi"
    
    # Always regenerate configs to avoid stale config issues
    # if (is_yazi_config_current $merged_config_dir $source_config_dir) {
    #     print "‚úÖ Yazi config is current, skipping regeneration"
    #     return $merged_config_dir
    # }
    
    print "üîÑ Regenerating Yazi configuration..."
    
    # Ensure output directory exists
    ensure_dir $"($merged_config_dir)/yazi.toml"
    
    # Merge each config file
    let config_files = ["yazi.toml", "keymap.toml", "theme.toml", "init.lua", "package.toml"]
    for file in $config_files {
        merge_config_file $source_config_dir $merged_config_dir $file
    }
    
    # Copy plugins directory
    copy_plugins_directory $source_config_dir $merged_config_dir
    
    print $"‚úÖ Yazi configuration generated successfully!"
    print $"   üìÅ Config saved to: ($merged_config_dir)"
    print "   üîÑ Config will auto-regenerate when source files change"
    
    $merged_config_dir
}

# Export main function for external use
export def main [yazelix_dir: string] {
    generate_merged_yazi_config $yazelix_dir | ignore
}